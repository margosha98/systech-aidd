---
alwaysApply: false
---
# Соглашения по написанию тестов

## Основные принципы
- TDD: тесты пишутся до реализации
- Тестируем поведение, не детали реализации
- Одна логическая проверка на тест (связанные проверки группируем)
- KISS: избегаем переусложнения тестовой инфраструктуры
- DRY: переиспользуем фикстуры, избегаем дублирования setup кода

## Что тестируем
- **Только основной функционал**: бизнес-логика, трансформации данных, API контракты
- **Критичные пути**: основные пользовательские сценарии, обработка ожидаемых ошибок
- **Публичные интерфейсы**: тестируем через публичные методы/функции
- **Пропускаем**: геттеры/сеттеры, тривиальный код, детали реализации

## Структура теста
```python
@pytest.mark.asyncio  # для async функций
async def test_{действие}_{ожидаемый_результат}(фикстуры):
    """Короткое описание что тестируется."""
    # Arrange: подготовка
    # Act: выполнение
    # Assert: проверка
```

## Фикстуры и моки
- `@pytest.fixture` для переиспользуемых тестовых объектов
- `AsyncMock` для async зависимостей (БД, API вызовы)
- `MagicMock` для синхронных объектов (Config, простые объекты)
- Мокаем внешние сервисы, никогда реальных API/БД вызовов в unit тестах
- In-memory SQLite (`:memory:`) для integration тестов

## Именование
- Файлы тестов: `test_{модуль}.py`
- Функции тестов: `test_{что}_{сценарий}` (например, `test_save_message_user`)
- Фикстуры: описательные существительные (например, `mock_database`, `llm_client`)

## Проверки
- Конкретные проверки: `assert x == y`, не `assert x`
- Проверяем изменения состояния, не вызовы методов (поведение важнее моков)
- Используем `mock.assert_called_once()`, `mock.call_args` для точек интеграции

## Async тестирование
- Помечаем `@pytest.mark.asyncio`
- `AsyncMock` для async методов: `mock.method = AsyncMock(return_value=...)`
- `async with` для context managers в фикстурах

## Ошибки
- Ожидаемые ошибки: `pytest.raises(ExceptionType, match="pattern")`
- Граничные случаи только если критичны для бизнеса
- Не тестируем ошибки фреймворка/библиотек

## Покрытие
- Высокое покрытие бизнес-логики (>80%)
- Игнорируем boilerplate, простые обертки
- `pytest-cov` для метрик, не как самоцель

## Антипаттерны
- ❌ Тестирование приватных методов напрямую
- ❌ Тесты дублирующие реализацию
- ❌ Избыточное мокирование (мокаем только границы)
- ❌ Несколько несвязанных проверок в одном тесте
- ❌ Тесты без четкой цели/описания
# Соглашения по написанию тестов

## Основные принципы
- TDD: тесты пишутся до реализации
- Тестируем поведение, не детали реализации
- Одна логическая проверка на тест (связанные проверки группируем)
- KISS: избегаем переусложнения тестовой инфраструктуры
- DRY: переиспользуем фикстуры, избегаем дублирования setup кода

## Что тестируем
- **Только основной функционал**: бизнес-логика, трансформации данных, API контракты
- **Критичные пути**: основные пользовательские сценарии, обработка ожидаемых ошибок
- **Публичные интерфейсы**: тестируем через публичные методы/функции
- **Пропускаем**: геттеры/сеттеры, тривиальный код, детали реализации

## Структура теста
```python
@pytest.mark.asyncio  # для async функций
async def test_{действие}_{ожидаемый_результат}(фикстуры):
    """Короткое описание что тестируется."""
    # Arrange: подготовка
    # Act: выполнение
    # Assert: проверка
```

## Фикстуры и моки
- `@pytest.fixture` для переиспользуемых тестовых объектов
- `AsyncMock` для async зависимостей (БД, API вызовы)
- `MagicMock` для синхронных объектов (Config, простые объекты)
- Мокаем внешние сервисы, никогда реальных API/БД вызовов в unit тестах
- In-memory SQLite (`:memory:`) для integration тестов

## Именование
- Файлы тестов: `test_{модуль}.py`
- Функции тестов: `test_{что}_{сценарий}` (например, `test_save_message_user`)
- Фикстуры: описательные существительные (например, `mock_database`, `llm_client`)

## Проверки
- Конкретные проверки: `assert x == y`, не `assert x`
- Проверяем изменения состояния, не вызовы методов (поведение важнее моков)
- Используем `mock.assert_called_once()`, `mock.call_args` для точек интеграции

## Async тестирование
- Помечаем `@pytest.mark.asyncio`
- `AsyncMock` для async методов: `mock.method = AsyncMock(return_value=...)`
- `async with` для context managers в фикстурах

## Ошибки
- Ожидаемые ошибки: `pytest.raises(ExceptionType, match="pattern")`
- Граничные случаи только если критичны для бизнеса
- Не тестируем ошибки фреймворка/библиотек

## Покрытие
- Высокое покрытие бизнес-логики (>80%)
- Игнорируем boilerplate, простые обертки
- `pytest-cov` для метрик, не как самоцель

## Антипаттерны
- ❌ Тестирование приватных методов напрямую
- ❌ Тесты дублирующие реализацию
- ❌ Избыточное мокирование (мокаем только границы)
- ❌ Несколько несвязанных проверок в одном тесте
- ❌ Тесты без четкой цели/описания
